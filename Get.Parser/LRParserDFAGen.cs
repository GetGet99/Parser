using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace Get.Parser;
public enum Associativity { Left, Right, NonAssociative }
public class LRParserDFAGen(IEqualityComparer<INonTerminal> nontermComparer, IEqualityComparer<ITerminal> termComparer)
{
    HashSetEqualityComparer hsComparer = new();
    // Code Generated by Gemini
    class HashSetEqualityComparer : IEqualityComparer<HashSet<LRItem>>
    {
        public bool Equals(HashSet<LRItem>? x, HashSet<LRItem>? y)
        {
            if (x == null || y == null)
            {
                return x == y;
            }
            return x.SetEquals(y);
        }

        public int GetHashCode(HashSet<LRItem> obj)
        {
            unchecked
            {
                int hash = 17;
                foreach (var state in obj)
                {
                    hash = hash * 31 + state.GetHashCode();
                }
                return hash;
            }
        }
    }
    public ILRParserDFA CreateDFA(IReadOnlyList<ICFGRule> grammar, INonTerminal startNode, (ITerminal[] Terminals, Associativity Associativity)[] precedenceList)
    {
        Dictionary<INonTerminal, HashSet<ICFGRule>> allRuleMap = new(nontermComparer);
        foreach (var rule in grammar)
        {
            if (!allRuleMap.TryGetValue(rule.Target, out var list))
            {
                list = [];
                allRuleMap[rule.Target] = list;
            }
            list.Add(rule);
        }
        FirstSetMetadata firstSetMetadata = new(allRuleMap, termComparer, nontermComparer);
        var startNodeLRItems = new HashSet<LRItem>();
        foreach (var rule in allRuleMap[startNode])
        {
            startNodeLRItems.Add(new(rule, 0, [null])); // null representing None
        }
        Dictionary<HashSet<LRItem>, LRParserDFA> dfaMaps = new(hsComparer);

        // Initial state creation
        var initialState = new LRParserDFA(nontermComparer, termComparer)
        {
            Items = Closure(startNodeLRItems, allRuleMap, firstSetMetadata),
        };
        dfaMaps[initialState.Items] = initialState;

        // Build the DFA states and transitions
        var worklist = new Queue<LRParserDFA>();
        worklist.Enqueue(initialState);

        while (worklist.Count > 0)
        {
            var currentDFA = worklist.Dequeue();

            foreach (var symbol in currentDFA.Items.Where(x => x.ExpressionAfter.Count > 0).Select(x => x.ExpressionAfter[0]))
            {

                var gotoItems = GoTo(currentDFA.Items, symbol, allRuleMap, firstSetMetadata);
                if (gotoItems.Count > 0)
                {
                    // Check if the state already exists
                    if (!dfaMaps.TryGetValue(gotoItems, out var nextState))
                    {
                        nextState = new LRParserDFA(nontermComparer, termComparer)
                        {
                            Items = gotoItems,
                        };
                        dfaMaps[gotoItems] = nextState;
                        worklist.Enqueue(nextState);
                    }

                    // Add transition to the current state
                    currentDFA.NextDFANode[symbol] = nextState;
                    if (symbol is ITerminal terminal)
                        ShiftReduceConflictCheck(currentDFA, terminal, precedenceList);
                }
            }
            var possibleReductions = currentDFA.Items.Where(item => item.ExpressionAfter.Count is 0).ToList();
            if (possibleReductions.Count is 0)
            {
                // no reductions
                continue;
            }
            else if (possibleReductions.Count is 1)
            {
                foreach (var term in possibleReductions[0].ReduceOn)
                {
                    if (term is not null)
                    {
                        if (currentDFA.Actions.ContainsKey(term))
                        {
                            throw new LRConflictException()
                            {
                                // TO DO: specify the other action that is conflict from currentDFA.Actions
                                ConflictedItems = [possibleReductions[0]],
                                ConflictType = ConflictType.ReduceReduce
                            };
                        }
                        currentDFA.Actions[term] = new LRDFAReduce(possibleReductions[0].OriginalCFGRule);
                        ShiftReduceConflictCheck(currentDFA, term, precedenceList);
                    }
                    else
                        currentDFA.OnEndSymbol = new LRDFAReduce(possibleReductions[0].OriginalCFGRule);
                }
            }
            else
            {
                throw new LRConflictException()
                {
                    ConflictedItems = possibleReductions,
                    ConflictType = ConflictType.ReduceReduce
                };
            }
        }

        // also add one last accept node:
        if (!initialState.NextDFANode.TryGetValue(startNode, out var acceptDFANode))
        {
            initialState.NextDFANode[startNode] = acceptDFANode = new(nontermComparer, termComparer) { Items = [/* not used */] };
        }
        if (acceptDFANode.OnEndSymbol is not null)
            throw new LRConflictException()
            {
                // TO DO: Specify Conflicted Items
                ConflictedItems = [],
                ConflictType = ConflictType.ReduceReduce
            };
        acceptDFANode.OnEndSymbol = new ILRDFAAccept();

        return initialState;
    }
    void ShiftReduceConflictCheck(LRParserDFA currentDFA, ITerminal term, (ITerminal[] Terminals, Associativity Associativity)[] precedenceList)
    {
        if (currentDFA.NextDFANode.ContainsKey(term) && currentDFA.Actions.ContainsKey(term))
        {
            // SHIFT-REDUCE CONFLICT
            int PrecedenceOf(ITerminal? terminal)
            {
                if (terminal is null) return -1;
                // for something like minus vs unary minus
                if (terminal is ITerminalWithCustomPrecedence t2)
                {
                    // we do the search for another terminal instead
                    terminal = t2.PrecedenceTerminal;
                }
                return Array.FindIndex(precedenceList, x => x.Terminals.Contains(terminal, termComparer));
            }
            ITerminal? LastTerm(IReadOnlyList<ISyntaxElement> elements)
            {
                for (int i = elements.Count - 1; i >= 0; i--)
                    if (elements[i] is ITerminal term)
                        return term;
                return null;
            }
            var termPrecedence = PrecedenceOf(term);
            (LRItem lrItem, int rulePrecedence) = (
                from item in currentDFA.Items
                where item.ExpressionAfter.Count is 0 && item.ReduceOn.Contains(term, termComparer)
                select (item, PrecedenceOf(LastTerm(item.ExpressionBefore)))
            ).MaxBy(x => x.Item2);

            if (termPrecedence < 0 && rulePrecedence < 0)
                // probably unintentional conflict as precedence is not declared
                throw new LRConflictException()
                {
                    // TO DO: specify the other action that is conflict from currentDFA.Actions
                    ConflictedItems = [], // possibleReductions[0]
                    ConflictType = ConflictType.ShiftReduce
                };
            var assoc = precedenceList[termPrecedence].Associativity;
            // so because we want the rule defined earlier to be seen as higher precedence
            // we negate the number to get the reverse order to index
            termPrecedence = -termPrecedence;
            rulePrecedence = -rulePrecedence;
            if (termPrecedence > rulePrecedence)
            {
                // SHIFT
                currentDFA.Actions.Remove(term); // remove reduce action
            }
            else if (termPrecedence == rulePrecedence)
            {
                if (assoc is Associativity.Left)
                {
                    // REDUCE
                    currentDFA.NextDFANode.Remove(term); // remove shift action
                }
                if (assoc is Associativity.Right)
                {
                    // SHIFT
                    currentDFA.Actions.Remove(term); // remove reduce action
                }
                if (assoc is Associativity.NonAssociative)
                {
                    throw new LRConflictException()
                    {
                        // TO DO: specify the other action that is conflict from currentDFA.Actions
                        ConflictedItems = [], // possibleReductions[0]
                        ConflictType = ConflictType.ShiftReduce
                    };
                }
            }
            else
            {
                // REDUCE
                currentDFA.NextDFANode.Remove(term); // remove shift action
            }
        }
    }

    HashSet<LRItem> Closure(HashSet<LRItem> lrItems, IReadOnlyDictionary<INonTerminal, HashSet<ICFGRule>> allRuleMap, FirstSetMetadata firstSetMetadata)
    {
        // Code by Gemini
        // This implementation skips epsilon transitions within the original rule.
        // You may need to modify it to consider epsilon transitions within the
        // productions depending on your specific grammar.
        var worklist = new Queue<LRItem>(lrItems);
        var closureDict = new Dictionary<LRItem, HashSet<ITerminal?>>();
        foreach (var item in lrItems)
        {
            closureDict[item with { ReduceOn = [] }] = new(item.ReduceOn, termComparer);
        }
        while (worklist.Count > 0)
        {
            var currentItem = worklist.Dequeue();

            // Check if the dot is before a non-terminal
            if (currentItem.DotIndex < currentItem.OriginalCFGRule.Expressions.Count &&
                currentItem.OriginalCFGRule.Expressions[currentItem.DotIndex] is INonTerminal nextNonTerminal)
            {
                // Find all productions for the non-terminal
                if (allRuleMap.TryGetValue(nextNonTerminal, out var productions))
                {
                    foreach (var production in productions)
                    {
                        // Create a new item with the dot shifted
                        var newReduceOn = firstSetMetadata.ComputeFirstSetOfSequence(new ListSpan<ISyntaxElement>(currentItem.ExpressionAfter, 1), currentItem.ReduceOn);
                        var newItem = new LRItem(production, 0, []);
                        if (!closureDict.TryGetValue(newItem, out var reduceOn))
                        {
                            closureDict[newItem] = reduceOn = newReduceOn;
                            // Add the new item to the worklist for further processing
                            worklist.Enqueue(newItem);
                        }
                        else
                        {
                            bool anyAdded = false;
                            foreach (var rn in newReduceOn)
                                if (reduceOn.Add(rn))
                                    anyAdded = true;
                            if (anyAdded)
                                // Add the new item to the worklist for further processing
                                worklist.Enqueue(newItem);
                        }
                    }
                }
            }
        }
        HashSet<LRItem> closureSet = [];
        foreach (var (item, val) in closureDict)
        {
            closureSet.Add(item with { ReduceOn = [.. val] });
        }
        return closureSet;
    }
    class FirstSetMetadata
    {
        
        public Dictionary<ISyntaxElement, HashSet<ITerminal?>> FirstSets { get; private set; }

        public FirstSetMetadata(
            IReadOnlyDictionary<INonTerminal, HashSet<ICFGRule>> grammar,
            IEqualityComparer<ITerminal> termComparer, IEqualityComparer<INonTerminal> nontermComparer)
        {
            FirstSets = new Dictionary<ISyntaxElement, HashSet<ITerminal?>>(new SyntaxElementComparer(termComparer, nontermComparer));

            // Initialize first sets for all syntax elements
            InitializeFirstSets(grammar);

            // Compute first sets
            ComputeFirstSets(grammar);
        }

        private void InitializeFirstSets(IReadOnlyDictionary<INonTerminal, HashSet<ICFGRule>> grammar)
        {
            foreach (var ruleSet in grammar.Values)
            {
                foreach (var rule in ruleSet)
                {
                    if (!FirstSets.ContainsKey(rule.Target)) FirstSets[rule.Target] = [];
                }
            }
        }

        private void ComputeFirstSets(IReadOnlyDictionary<INonTerminal, HashSet<ICFGRule>> grammar)
        {
            bool changed;
            do
            {
                changed = false;
                foreach (var ruleSet in grammar.Values)
                {
                    foreach (var rule in ruleSet)
                    {
                        var targetFirstSet = FirstSets[rule.Target];

                        foreach (var element in rule.Expressions)
                        {
                            if (element is ITerminal terminal)
                            {
                                if (targetFirstSet.Add(terminal))
                                    changed = true;
                                break;
                            }
                            else if (element is INonTerminal nonTerminal)
                            {
                                var elementFirstSet = FirstSets[nonTerminal];
                                if (targetFirstSet.UnionWithExcludeEpsilon(elementFirstSet))
                                    changed = true;

                                if (!elementFirstSet.Contains(null)) // Epsilon not in first set
                                    break;
                            }
                        }
                    }
                }
            } while (changed);
        }
        public HashSet<ITerminal?> ComputeFirstSetOfSequence(IReadOnlyList<ISyntaxElement> sequence, ITerminal?[] lookahead)
        {
            var result = new HashSet<ITerminal?>();
            bool hasEpsilon = true;

            foreach (var element in sequence)
            {
                if (element is ITerminal terminal)
                {
                    result.Add(terminal);
                    hasEpsilon = false;
                    break;
                }
                else if (element is INonTerminal nonTerminal)
                {
                    var firstSet = FirstSets[nonTerminal];
                    result.UnionWithExcludeEpsilon(firstSet);

                    if (!firstSet.Contains(null)) // Epsilon not in First(nonTerminal)
                    {
                        hasEpsilon = false;
                        break;
                    }
                }
            }

            if (hasEpsilon)
            {
                result.UnionWith(lookahead);
            }

            return result;
        }
    }

    HashSet<LRItem> GoTo(HashSet<LRItem> lrItems, ISyntaxElement symbol, IReadOnlyDictionary<INonTerminal, HashSet<ICFGRule>> allRuleMap, FirstSetMetadata firstSetMetadata)
    {
        var gotoItems = new HashSet<LRItem>();
        foreach (var item in lrItems)
        {
            if (item.DotIndex < item.OriginalCFGRule.Expressions.Count &&
                item.OriginalCFGRule.Expressions[item.DotIndex] == symbol)
            {
                gotoItems.Add(new LRItem(item.OriginalCFGRule, item.DotIndex + 1, item.ReduceOn));
            }
        }
        return Closure(gotoItems, allRuleMap, firstSetMetadata);
    }
}
public readonly record struct LRItem(ICFGRule OriginalCFGRule, int DotIndex, ITerminal?[] ReduceOn)
{
    public INonTerminal Target => OriginalCFGRule.Target;
    public IReadOnlyList<ISyntaxElement> ExpressionBefore => new ListSpan<ISyntaxElement>(OriginalCFGRule.Expressions, 0, DotIndex);
    public IReadOnlyList<ISyntaxElement> ExpressionAfter => new ListSpan<ISyntaxElement>(OriginalCFGRule.Expressions, DotIndex);
    public override string ToString()
    {
        return $"{Target} -> {string.Join(" ", from x in ExpressionBefore select x.ToString())} . {string.Join(" ", from x in ExpressionAfter select x.ToString())}, {(
            ReduceOn is null ? "<null>" : string.Join(" ", from x in ReduceOn select x?.ToString() ?? "[END]")
        )}";
    }
    public bool Equals(LRItem other)
    {
        return OriginalCFGRule.Equals(other.OriginalCFGRule) &&
               DotIndex == other.DotIndex &&
               ReduceOn.SequenceEqual(other.ReduceOn);
    }

    public override int GetHashCode()
    {
        int hash = 17;
        hash = hash * 31 + OriginalCFGRule.GetHashCode();
        hash = hash * 31 + DotIndex.GetHashCode();

        // Combine hashes for array elements
        foreach (var item in ReduceOn)
        {
            hash = hash * 31 + (item?.GetHashCode() ?? 0);
        }

        return hash;
    }
}
public partial interface ICFGRule
{
    INonTerminal Target { get; }
    IReadOnlyList<ISyntaxElement> Expressions { get; }
}
public interface ILRParserDFA
{
    /// <summary>
    /// Get the action given a stack and the next token
    /// </summary>
    /// <param name="stack">The current stack of values</param>
    /// <param name="nextToken">The next lookahead token</param>
    /// <returns>null if we are shifting. Otherwise, return the appropriate action (either accept or reduce).</returns>
    ILRDFAAction? GetAction(IReadOnlyList<ISyntaxElementValue> stack, ITerminalValue? nextToken);
}
public record struct ILRDFAAccept : ILRDFAAction;
public record struct LRDFAReduce(ICFGRule Rule) : ILRDFAAction;
public interface ILRDFAAction;
public interface ISyntaxElement;
public interface INonTerminal : ISyntaxElement;
public interface ITerminal : ISyntaxElement;
public interface ITerminalWithCustomPrecedence : ITerminal
{
    ITerminal PrecedenceTerminal { get; }
}
public enum ConflictType
{
    ShiftReduce,
    ReduceReduce
}
public class LRConflictException() : Exception("An resolved conflict was found")
{
    public required ConflictType ConflictType { get; init; }
    public required IReadOnlyList<LRItem> ConflictedItems { get; init; }
}
static class HashSetExtensions
{
    public static bool UnionWithExcludeEpsilon(this HashSet<ITerminal?> target, HashSet<ITerminal?> source)
    {
        bool changed = false;
        foreach (var item in source)
        {
            if (item != null && target.Add(item))
            {
                changed = true;
            }
        }
        return changed;
    }
}
class SyntaxElementComparer(IEqualityComparer<ITerminal> termComparer, IEqualityComparer<INonTerminal> nontermComparer) : IEqualityComparer<ISyntaxElement>
{
    public bool Equals(ISyntaxElement? x, ISyntaxElement? y)
    {
        if (x is ITerminal x1 && y is ITerminal y1) return termComparer.Equals(x1, y1);
        if (x is INonTerminal x2 && y is INonTerminal y2) return nontermComparer.Equals(x2, y2);
        return false;
    }

    public int GetHashCode([DisallowNull] ISyntaxElement obj)
    {
        if (obj is ITerminal term) return termComparer.GetHashCode(term);
        if (obj is INonTerminal nonterm) return nontermComparer.GetHashCode(nonterm);
        return obj.GetHashCode();
    }
}